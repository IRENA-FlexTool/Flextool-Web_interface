import csv
import sys
from enum import auto, Enum, unique
import json
from pathlib import Path
import re
from shutil import copyfile
from contextlib import contextmanager

from django.contrib.auth.decorators import login_required
from django.contrib.auth.mixins import LoginRequiredMixin
from django.http import (
    Http404,
    HttpResponse,
    HttpResponseBadRequest,
    JsonResponse,
    HttpResponseServerError,
)
from django.shortcuts import get_object_or_404, render
from django.urls import reverse
from django.views import generic
from spinedb_api import (
    DatabaseMapping,
    to_database,
    SpineIntegrityError,
    SpineDBVersionError,
    SpineDBAPIError,
)
from .models import Execution, Project, PROJECT_NAME_LENGTH
from . import executor
from .exception import FlextoolException

FLEXTOOL_PROJECT_TEMPLATE = Path(__file__).parent / "master_project"
FLEXTOOL_PROJECTS_ROOT = Path(__file__).parent / "user_projects"

PHYSICAL_OBJECT_CLASS_NAMES = {
    "commodity",
    "connection",
    "group",
    "node",
    "profile",
    "reserve",
    "unit",
}

MODEL_OBJECT_CLASS_NAMES = {
    "model",
    "timeblockSet",
    "timeline",
    "solve",
}


@unique
class Key(Enum):
    ALTERNATIVE_ID = "alternative_id"
    CLASS_ID = "class_id"
    ENTITY_ID = "entity_id"
    OBJECT_CLASS_ID = "object_class_id"
    OBJECT_ID = "object_id"
    RELATIONSHIP_CLASS_ID = "relationship_class_id"
    VALUE_LIST_IDS = "value_list_ids"

    def __str__(self):
        return self.value


@unique
class Database(Enum):
    MODEL = auto()
    RESULT = auto()


def _get_and_validate(dictionary, key, expected_type, required=True):
    """Returns value with given key from dictionary.

    Raises if value doesn't exist or is of wrong type.

    Args:
        dictionary (dict): a dictionary
        key (Any): dictionary key
        expected_type (Type): value's expected type
        required (bool): If True, missing key raises an exception

    Returns:
        Any: value corresponding to key or None key is missing
    """
    try:
        x = dictionary[key]
    except KeyError as missing:
        if required:
            raise FlextoolException(f"Missing {missing}.")
        return None
    if not isinstance(x, expected_type):
        if isinstance(expected_type, tuple):
            raise FlextoolException(
                f"'{key}' is of wrong type, expected one of {expected_type}"
            )
        raise FlextoolException(
            f"'{key}' is of wrong type '{type(x).__name__}', expected {expected_type.__name__}"
        )
    return x


def _convert_ints_to_floats(value):
    """Converts integers to floats in-place in indexed values.

    Args:
        value (Any): parameter value

    Returns:
        Any: value converted to float
    """
    if isinstance(value, int):
        return float(value)
    if not isinstance(value, dict):
        return value
    type_ = value["type"]
    if type_ == "map":
        data = [[x, float(y) if isinstance(y, int) else y] for x, y in value["data"]]
        value["data"] = data
    elif type == "array":
        data = [float(y) if isinstance(y, int) else y for y in value["data"]]
        value["data"] = data
    return value


class IndexView(LoginRequiredMixin, generic.ListView):
    template_name = "flextool3/index.html"
    context_object_name = "projects"
    login_url = "accounts/login/"

    def get_queryset(self):
        """Returns user's projects."""
        return Project.objects.filter(user_id=self.request.user.id)


class DetailView(LoginRequiredMixin, generic.DetailView):
    model = Project
    template_name = "flextool3/detail.html"
    login_url = "accounts/login/"


def _ensure_database_up_to_date(func, database, request, pk):
    """Returns special response if model database needs an upgrade; otherwise returns response generated by func.

    Args:
        func (Callable): function returning HttpResponse
        database (Database): which database is going to be used
        request (HttpRequest): request object
        pk (int): project's primary key

    Returns:
        HttpResponse: response object
    """
    project = get_object_or_404(Project, pk=pk)
    if database == Database.MODEL:
        db_path = project.model_database_path()
        create_database = False
    else:
        db_path = project.results_database_path()
        create_database = not db_path.exists()
        if create_database:
            db_path.parent.mkdir(parents=True, exist_ok=True)
    db_url = "sqlite:///" + str(db_path)
    try:
        db_map = DatabaseMapping(db_url, create=create_database)
    except SpineDBVersionError:
        _backup_database(db_path)
        try:
            db_map = DatabaseMapping(db_url, upgrade=True)
        except SpineDBAPIError as error:
            return HttpResponseServerError(f"Failed to upgrade database: {error}")
        else:
            db_map.connection.close()
            context = {"database": "model" if database == Database.MODEL else "result"}
            return render(request, "flextool3/database_upgraded.html", context)
    except SpineDBAPIError as error:
        return HttpResponseServerError(f"Failed to open database mapping: {error}")
    else:
        try:
            return func(project, db_map)
        finally:
            db_map.connection.close()


def _backup_database(database_path):
    """Backs up a file.

    Args:
        database_path (Path): path to .sqlite file
    """
    backup_path = database_path.parent / (database_path.name + ".backup")
    copyfile(database_path, backup_path)


@login_required
def edit(request, pk):
    def render_edit(project, _):
        context = {"project": project}
        return render(request, "flextool3/edit.html", context)

    return _ensure_database_up_to_date(render_edit, Database.MODEL, request, pk)


@login_required
def entities(request, pk, class_id):
    def render_entities(project, db_map):
        entity_class = (
            db_map.query(db_map.entity_class_sq)
            .filter(db_map.entity_class_sq.c.id == class_id)
            .first()
        )
        if entity_class is None:
            return HttpResponseBadRequest("Entity class does not exist.")
        context = {"project": project, "entity_class": entity_class}
        return render(request, "flextool3/entities.html", context)

    return _ensure_database_up_to_date(render_entities, Database.MODEL, request, pk)


@login_required
def scenarios(request, pk):
    def render_scenarios(project, _):
        context = {"project": project}
        return render(request, "flextool3/scenarios.html", context)

    return _ensure_database_up_to_date(render_scenarios, Database.MODEL, request, pk)


class RunView(LoginRequiredMixin, generic.DetailView):
    """View to generate the Run page."""

    model = Project
    template_name = "flextool3/run.html"


@login_required
def results(request, pk):
    def render_results(project, _):
        context = {"project": project}
        return render(request, "flextool3/results.html", context)

    return _ensure_database_up_to_date(render_results, Database.RESULT, request, pk)


@login_required
def projects(request):
    if request.method != "POST":
        raise Http404()
    body = json.loads(request.body)
    try:
        question = body["type"]
    except KeyError as missing:
        return HttpResponseBadRequest(f"Missing '{missing}'.")
    if question == "project list?":
        return project_list(request.user.id)
    if question == "create project?":
        return create_project(request.user, body)
    if question == "destroy project?":
        return destroy_project(request.user, body)
    return HttpResponseBadRequest("Unknown 'type'.")


def project_list(user_id):
    response = {
        "projects": [
            project.project_list_data()
            for project in Project.objects.filter(user_id=user_id)
        ]
    }
    return JsonResponse(response)


def create_project(user, request_body):
    try:
        project_name = request_body["name"]
    except KeyError as missing:
        return HttpResponseBadRequest(f"Missing '{missing}'")
    project_name = project_name[:PROJECT_NAME_LENGTH].strip()
    if re.match(r"(^\w&)|(^\w(\w|\s)*\w$)", project_name) is None:
        return HttpResponseBadRequest("Invalid project name.")
    try:
        new_project = Project.create(
            user,
            project_name,
            FLEXTOOL_PROJECTS_ROOT,
            FLEXTOOL_PROJECT_TEMPLATE,
        )
    except FlextoolException as error:
        return HttpResponseBadRequest(str(error))
    new_project.save()
    return JsonResponse({"project": new_project.project_list_data()})


def destroy_project(user, request_body):
    """Destroys a project by it from the database and removing the project directory.

    Args:
        user (User): project owner
        request_body (dict): destroy request body

    Returns:
        HttpResponse: response to be sent to client
    """
    try:
        id_ = request_body["id"]
    except KeyError as missing:
        return HttpResponseBadRequest(f"Missing '{missing}'.")
    try:
        project = Project.objects.get(user_id=user.id, pk=id_)
    except Project.DoesNotExist:
        return HttpResponseBadRequest("Project does not exist.")
    project.remove_project_dir()
    project.delete()
    return JsonResponse({"id": id_})


@login_required
def model(request):
    """Performs model database queries and updates.

    Request's body should contain a JSON object that specifies the query/update to perform.

    Args:
        request (HttpRequest): request object

    Returns:
        HttpResponse: response to client
    """

    def handle_model_specific_types(type_, project, body):
        if type_ == "available relationship objects?":
            return get_available_relationship_objects(project, body)
        if type_ == "scenarios?":
            return get_scenarios(project)
        if type_ == "available relationship objects?":
            return get_available_relationship_objects(project, body)
        if type_ == "parameter value lists?":
            return get_parameter_value_lists(project, body)
        if type_ == "physical classes?":
            return get_class_set(project, PHYSICAL_OBJECT_CLASS_NAMES)
        if type_ == "model classes?":
            return get_class_set(project, MODEL_OBJECT_CLASS_NAMES)
        if type_ == "commits?":
            return get_commits(project, body)
        if type_ == "make base alternative":
            return make_base_alternative(project, body)
        if type_ == "commit":
            return commit(project, body)
        return None

    return _resolve_interface_request(
        request, Database.MODEL, handle_model_specific_types
    )


def _resolve_interface_request(request, database, additional_type_handler):
    """Resolves model or analysis interface request.

    Args:
        request (HTTPRequest): request
        database (Database): target database
        additional_type_handler (Callable): callable that handles additional types

    Returns:
        HttpResponse: response to client
    """
    if request.method != "POST":
        raise Http404()
    body = json.loads(request.body)
    try:
        project = _resolve_project(request, body)
    except FlextoolException as error:
        return HttpResponseBadRequest(str(error))
    try:
        type_ = body["type"]
    except KeyError as missing:
        return HttpResponseBadRequest(f"Missing '{missing}'.")
    try:
        if type_ == "object classes?":
            return get_object_classes(project, database)
        if type_ == "objects?":
            return get_objects(project, database, body)
        if type_ == "relationship classes?":
            return get_relationship_classes(project, database)
        if type_ == "relationships?":
            return get_relationships(project, database, body)
        if type_ == "parameter definitions?":
            return get_parameter_definitions(project, database, body)
        if type_ == "parameter values?":
            return get_parameter_values(project, database, body)
        if type_ == "alternatives?":
            return get_alternatives(project, database)
        response = additional_type_handler(type_, project, body)
        if response is not None:
            return response
    except SpineDBVersionError:
        return HttpResponseBadRequest("Error: database version mismatch.")
    return HttpResponseBadRequest("Unknown 'type'.")


def _resolve_project(request, body):
    """Resolves target project according to client request.

    Args:
        request (HttpRequest): request object
        body (dict): request body

    Returns:
        Project: target project
    """
    try:
        project_id = body["projectId"]
    except KeyError as missing:
        raise FlextoolException(f"Missing '{missing}'.")
    try:
        project = Project.objects.get(id=project_id)
    except Project.DoesNotExist:
        raise FlextoolException("Project does not exist.")
    if project.user.id != request.user.id:
        raise FlextoolException("Project does not exist.")
    return project


def get_object_classes(project, database):
    """Queries object classes in one of project's database.

    Args:
        project (Project): target project
        database (Database): target database

    Returns:
        HttpResponse: object classes
    """
    with database_map(project, database) as db_map:
        classes = [row._asdict() for row in db_map.query(db_map.object_class_sq)]
        return JsonResponse({"classes": classes})


def get_objects(project, database, request_body):
    """Queries objects in one of project's databases.

    Optional entries in request body:

    - 'object_class_id': object class id for filtering

    Args:
        project (Project): target project
        database (Database): target database
        request_body (dict): request body

    Returns:
        HttpResponse: objects
    """
    class_id = request_body.get(Key.OBJECT_CLASS_ID.value)
    if class_id is not None and not isinstance(class_id, int):
        return HttpResponseBadRequest(f"Wrong '{Key.OBJECT_CLASS_ID}' data type.")
    with database_map(project, database) as db_map:
        sq = db_map.object_sq
        if class_id is not None:
            sq = db_map.query(sq).filter(sq.c.class_id == class_id).subquery()
        objects = [row._asdict() for row in db_map.query(sq).order_by(sq.c.name)]
        return JsonResponse({"objects": objects})


def get_parameter_definitions(project, database, request_body):
    """Queries entity parameter definitions in one of project's databases.

    Optional entries in request body:

    - 'class_id': entity class id for filtering

    Args:
        project (Project): target project
        database (Database): target database
        request_body (dict): request body

    Returns:
        HttpResponse: entity parameter definitions
    """
    class_id = request_body.get(Key.CLASS_ID.value)
    if class_id is not None and not isinstance(class_id, int):
        return HttpResponseBadRequest(f"Wrong '{Key.CLASS_ID}' data type.")
    with database_map(project, database) as db_map:
        sq = db_map.parameter_definition_sq
        if class_id is not None:
            sq = db_map.query(sq).filter(sq.c.entity_class_id == class_id).subquery()
        definitions = [row._asdict() for row in db_map.query(sq).order_by(sq.c.name)]
        for definition in definitions:
            value_bytes = definition["default_value"]
            if value_bytes is not None:
                definition["default_value"] = str(value_bytes, encoding="utf-8")
        return JsonResponse({"definitions": definitions})


def get_parameter_values(project, database, request_body):
    """Queries entity parameter values in one of project's databases.

    Optional entries in request body:

    - 'class_id': entity class id for filtering
    - 'entity_id': entity id for filtering, ignored if entity_class_id is given
    - 'alternative_id' alternative id for filtering

    Args:
        project (Project): target project
        database (Database): target database
        request_body (dict): request body

    Returns:
        HttpResponse: parameter values
    """
    class_id = request_body.get(Key.CLASS_ID.value)
    if class_id is not None and not isinstance(class_id, int):
        return HttpResponseBadRequest(f"Wrong '{Key.CLASS_ID}' data type.")
    entity_id = request_body.get(Key.ENTITY_ID.value)
    if entity_id is not None and not isinstance(entity_id, int):
        return HttpResponseBadRequest(f"Wrong '{Key.ENTITY_ID}' data type.")
    alternative_id = request_body.get(Key.ALTERNATIVE_ID.value)
    if alternative_id is not None and not isinstance(alternative_id, int):
        return HttpResponseBadRequest(f"Wrong '{Key.ALTERNATIVE_ID}' data type.")
    with database_map(project, database) as db_map:
        sq = db_map.parameter_value_sq
        if class_id is not None:
            sq = db_map.query(sq).filter(sq.c.entity_class_id == class_id).subquery()
        elif entity_id is not None:
            sq = db_map.query(sq).filter(sq.c.entity_id == entity_id).subquery()
        if alternative_id is not None:
            sq = (
                db_map.query(sq)
                .filter(sq.c.alternative_id == alternative_id)
                .subquery()
            )
        values = [row._asdict() for row in db_map.query(sq)]
        for value in values:
            value_bytes = value["value"]
            if value_bytes is not None:
                value["value"] = str(value_bytes, encoding="utf-8")
        return JsonResponse({"values": values})


def get_relationship_classes(project, database):
    """Queries relationship classes in one of project's databases.

    Args:
        project (Project): target project
        database (Database): target database

    Returns:
        HttpResponse: relationship classes
    """
    with database_map(project, database) as db_map:
        classes = [
            row._asdict() for row in db_map.query(db_map.ext_relationship_class_sq)
        ]
        return JsonResponse({"classes": classes})


def _relationship_object_ids(db_map, class_id):
    """Gather's names and ids of all objects that belong to relationship class' dimensions.

    Args:
        db_map (DatabaseMapping): database map
        class_id (int): relationship class id

    Returns:
        list of dict: dicts of object ids keyed by names; the dicts are sorted by relationship dimension
    """
    class_components = (
        db_map.query(db_map.ext_relationship_class_sq)
        .filter(db_map.ext_relationship_class_sq.c.id == class_id)
        .order_by(db_map.ext_relationship_class_sq.c.dimension)
        .all()
    )
    object_ids = list()
    for component in class_components:
        objects = (
            db_map.query(db_map.object_sq)
            .filter(db_map.object_sq.c.class_id == component.object_class_id)
            .all()
        )
        object_ids.append({o.name: o.id for o in objects})
    return object_ids


def get_relationships(project, database, request_body):
    """Queries relationships in one of project's databases.

    Optional entries in request body:

    - 'relationship_class_id': relationship class id for filtering

    Args:
        project (Project): target project
        database (Database): target database
        request_body (dict): request body

    Returns:
        HttpResponse: relationships
    """
    class_id = request_body.get(Key.RELATIONSHIP_CLASS_ID.value)
    if class_id is not None and not isinstance(class_id, int):
        return HttpResponseBadRequest(f"Wrong '{Key.RELATIONSHIP_CLASS_ID}' data type.")
    with database_map(project, database) as db_map:
        sq = db_map.ext_relationship_sq
        if class_id is not None:
            sq = db_map.query(sq).filter(sq.c.class_id == class_id).subquery()
        relationships = [
            row._asdict()
            for row in db_map.query(sq).order_by(sq.c.name, sq.c.dimension)
        ]
        return JsonResponse({"relationships": relationships})


def get_available_relationship_objects(project, request_body):
    """Queries objects of relationship's object classes in model database.

    Required entries in request body:

    - 'relationship_class_id': relationship class id

    Args:
        project (Project): target project
        request_body (dict): request body

    Returns:
        HttpResponse: lists of names of available objects for each relationship dimension
    """
    class_id = _get_and_validate(request_body, Key.RELATIONSHIP_CLASS_ID.value, int)
    with database_map(project, Database.MODEL) as db_map:
        available_objects = []
        for names_and_ids in _relationship_object_ids(db_map, class_id):
            available_objects.append(sorted(names_and_ids))
        return JsonResponse({"available_objects": available_objects})


def get_parameter_value_lists(project, request_body):
    """Queries parameter value lists in model database.

    Optional entries in request body:

    - 'value_list_ids': list of parameter list ids for filtering

    Args:
        project (Project): target project
        request_body (dict): request body

    Returns:
        HttpResponse: parameter value lists
    """

    def concatenate_bag(bag):
        skeleton = len(bag) * [None]
        for index, x in bag.items():
            skeleton[index] = x
        return skeleton

    list_ids = request_body.get(Key.VALUE_LIST_IDS.value)
    if list_ids is not None:
        if not isinstance(list_ids, list):
            return HttpResponseBadRequest(f"Wrong '{Key.VALUE_LIST_IDS}' data type.")
        if any(not isinstance(id_, int) for id_ in list_ids):
            return HttpResponseBadRequest(f"Wrong data type in '{Key.VALUE_LIST_IDS}'.")
    with database_map(project, Database.MODEL) as db_map:
        sq = db_map.ord_list_value_sq
        if list_ids is not None:
            sq = (
                db_map.query(sq)
                .filter(sq.c.parameter_value_list_id.in_(list_ids))
                .subquery()
            )
        value_list_items = db_map.query(sq).all()
        collected_values = {}
        collected_types = {}
        for list_item in value_list_items:
            bag_of_values = collected_values.setdefault(
                list_item.parameter_value_list_id, {}
            )
            bag_of_values[list_item.index] = str(list_item.value, encoding="utf-8")
            bag_of_types = collected_types.setdefault(
                list_item.parameter_value_list_id, {}
            )
            bag_of_types[list_item.index] = list_item.type
        concatenated_values = {
            list_id: concatenate_bag(bag) for list_id, bag in collected_values.items()
        }
        concatenated_types = {
            list_id: concatenate_bag(bag) for list_id, bag in collected_types.items()
        }
        value_lists = []
        for list_item in value_list_items:
            values = concatenated_values.pop(list_item.parameter_value_list_id, None)
            if values is None:
                continue
            dictified = {
                "id": list_item.parameter_value_list_id,
                "value_list": values,
                "type_list": concatenated_types.pop(list_item.parameter_value_list_id),
            }
            value_lists.append(dictified)
        return JsonResponse({"lists": value_lists})


def get_commits(project, request_body):
    """Queries commits in model database.

    Args:
        project (Project): target project
        request_body (dict): request body

    Returns:
        HttpResponse: commits
    """
    with database_map(project, Database.MODEL) as db_map:
        commits = [row._asdict() for row in db_map.query(db_map.commit_sq)]
        # The last commit is always a dummy one.
        return JsonResponse({"commits": commits})


def make_base_alternative(project, request_body):
    """Creates and commits an alternative called 'Base' if there aren't any alternatives in the database.

    Args:
        project (Project): target project
        request_body (dict): request body

    Returns:
        HttpResponse: status or error message
    """
    with database_map(project, Database.MODEL) as db_map:
        if db_map.query(db_map.alternative_sq).all():
            return JsonResponse({"inserted": []})
        try:
            _insert_alternatives(db_map, {"alternative": [{"name": "Base"}]})
        except FlextoolException as e:
            return HttpResponseBadRequest(f"Failed to create 'Base' alternative: {e}")
        try:
            db_map.commit_session("Add Base alternative.")
        except SpineDBAPIError as e:
            return HttpResponseBadRequest(f"Failed to commit: {e}")
        return JsonResponse(
            {
                "alternatives": [
                    row._asdict()
                    for row in db_map.query(db_map.alternative_sq).order_by(
                        db_map.alternative_sq.c.name
                    )
                ]
            }
        )


def commit(project, request_body):
    """Updates model database.

    Args:
        project (Project): target project
        request_body (dict): request body

    Returns:
        HttpResponse: commit status or error message
    """
    try:
        commit_message = request_body["message"]
    except KeyError as missing:
        return HttpResponseBadRequest(f"Missing '{missing}'.")
    if not isinstance(commit_message, str):
        return HttpResponseBadRequest("Commit message is of wrong type.")
    with database_map(project, Database.MODEL) as db_map:
        try:
            _delete_from_model(db_map, request_body)
            inserted = _insert_to_model(db_map, request_body)
            _update_model(db_map, request_body)
        except SpineIntegrityError as e:
            return HttpResponseBadRequest(f"Database integrity error: {e}")
        except FlextoolException as e:
            return HttpResponseBadRequest(str(e))
        try:
            db_map.commit_session(commit_message)
        except SpineDBAPIError as e:
            return HttpResponseBadRequest(f"Failed to commit: {e}")
        return JsonResponse({"inserted": inserted} if inserted else {})


def _update_model(db_map, request_body):
    """Updates model database.

    Args:
        db_map (DatabaseMapping): database mapping
        request_body (dict): request body
    """
    updates = request_body.get("updates")
    if updates is None:
        return
    if not isinstance(updates, dict):
        raise FlextoolException("'updates' wasn't of expected type.")
    class_id = _get_and_validate(request_body, Key.CLASS_ID.value, int, required=False)
    _update_alternatives(db_map, updates)
    _update_scenarios(db_map, updates)
    _update_scenario_alternatives(db_map, updates)
    _update_objects(db_map, updates)
    _update_relationships(db_map, updates, class_id)
    _update_parameter_values(db_map, updates)


def _delete_from_model(db_map, request_body):
    """Deletes items from model database.

    Args:
        db_map (DatabaseMapping): database mapping
        request_body (dict): request body
    """
    deletions = _get_and_validate(request_body, "deletions", dict, required=False)
    if deletions is None:
        return
    try:
        converted_deletions = {key: set(value) for key, value in deletions.items()}
    except TypeError:
        raise FlextoolException("Wrong data type in deletions.")
    db_map.cascade_remove_items(cache=None, **converted_deletions)


def _insert_to_model(db_map, request_body):
    """Inserts items to model database.

    Args:
        db_map (DatabaseMapping): database mapping
        request_body (dict): request body

    Returns:
        dict of dict: inserted item ids
    """
    insertions = _get_and_validate(request_body, "insertions", dict, required=False)
    if insertions is None:
        return {}
    class_id = _get_and_validate(request_body, Key.CLASS_ID.value, int, required=False)
    inserted = {}
    inserted_alternatives = _insert_alternatives(db_map, insertions)
    if inserted_alternatives:
        inserted["alternative"] = inserted_alternatives
    inserted_scenarios = _insert_scenarios(db_map, insertions)
    if inserted_scenarios:
        inserted["scenario"] = inserted_scenarios
    scenario_alternatives = _insert_scenario_alternatives(db_map, insertions)
    if scenario_alternatives:
        inserted["scenario_alternative"] = scenario_alternatives
    objects = _insert_objects(db_map, insertions, class_id)
    if objects:
        inserted["object"] = objects
    relationships = _insert_relationships(db_map, insertions, class_id)
    if relationships:
        inserted["relationship"] = relationships
    _insert_parameter_values(db_map, insertions, class_id)
    return inserted


def _update_alternatives(db_map, updates):
    """Updates alternatives in model database.

    Args:
        db_map (DatabaseMapping): database mapping
        updates (dict): database updates
    """
    alternative_updates = _get_and_validate(
        updates, "alternative", list, required=False
    )
    if not alternative_updates:
        return
    sterilized_updates = []
    for update in alternative_updates:
        sterilized = {
            "id": _get_and_validate(update, "id", int),
            "name": _get_and_validate(update, "name", str),
        }
        sterilized_updates.append(sterilized)
    try:
        _, errors = db_map.update_alternatives(*sterilized_updates, strict=True)
        if errors:
            raise FlextoolException("Errors while updating alternatives.")
    except SpineIntegrityError as error:
        raise FlextoolException(f"Database integrity error: {error}")


def _update_scenarios(db_map, updates):
    """Updates scenarios in model database.

    Args:
        db_map (DatabaseMapping): database mapping
        updates (dict): database updates
    """
    scenario_updates = _get_and_validate(updates, "scenario", list, required=False)
    if not scenario_updates:
        return
    sterilized_updates = []
    for update in scenario_updates:
        sterilized = {
            "id": _get_and_validate(update, "id", int),
            "name": _get_and_validate(update, "name", str),
        }
        sterilized_updates.append(sterilized)
    try:
        _, errors = db_map.update_scenarios(*sterilized_updates, strict=True)
        if errors:
            raise FlextoolException("Errors while updating scenarios.")
    except SpineIntegrityError as error:
        raise FlextoolException(f"Database integrity error: {error}")


def _update_scenario_alternatives(db_map, updates):
    """Updates scenario alternatives in model database.

    Args:
        db_map (DatabaseMapping): database mapping
        updates (dict): database updates
    """
    scenario_alternative_updates = _get_and_validate(
        updates, "scenario_alternative", list, required=False
    )
    if not scenario_alternative_updates:
        return
    alternative_ids = {
        item.name: item.id for item in db_map.query(db_map.alternative_sq)
    }
    sterilized_updates = []
    for update in scenario_alternative_updates:
        sterilized = {
            "id": _get_and_validate(update, "id", int),
            "alternative_id": alternative_ids[
                _get_and_validate(update, "alternative_name", str)
            ],
        }
        sterilized_updates.append(sterilized)
    try:
        _, errors = db_map.update_scenario_alternatives(
            *sterilized_updates, strict=True
        )
        if errors:
            raise FlextoolException("Errors while updating scenario alternatives.")
    except SpineIntegrityError as error:
        raise FlextoolException(f"Database integrity error: {error}")


def _update_objects(db_map, updates):
    """Updates objects in model database.

    Args:
        db_map (DatabaseMapping): database mapping
        updates (dict): database updates
    """
    object_updates = _get_and_validate(updates, "object", list, required=False)
    if not object_updates:
        return
    sterilized_updates = []
    for update in object_updates:
        sterilized = {
            "id": _get_and_validate(update, "id", int),
            "name": _get_and_validate(update, "name", str),
        }
        sterilized_updates.append(sterilized)
    try:
        _, errors = db_map.update_objects(*sterilized_updates, strict=True)
        if errors:
            raise FlextoolException("Errors while updating objects.")
    except SpineIntegrityError as e:
        raise FlextoolException(f"Database integrity error: {e}")


def _update_relationships(db_map, updates, class_id):
    """Updates relationships in model database.

    Args:
        db_map (DatabaseMapping): database mapping
        updates (dict): database updates
        class_id (int): relationship class id
    """
    relationship_updates = _get_and_validate(
        updates, "relationship", list, required=False
    )
    if not relationship_updates:
        return
    if class_id is None:
        raise FlextoolException("'class_id' is required when updating relationships.")
    sterilized_updates = []
    object_ids = _relationship_object_ids(db_map, class_id)
    for update in relationship_updates:
        object_names = _get_and_validate(update, "object_name_list", list)
        object_id_list = [
            object_ids[dimension][object_names[dimension]]
            for dimension, ids in enumerate(object_ids)
        ]
        sterilized = {
            "id": _get_and_validate(update, "id", int),
            "name": _get_and_validate(update, "name", str),
            "object_id_list": object_id_list,
        }
        sterilized_updates.append(sterilized)
    del relationship_updates  # Don't use updates from this point onwards.
    try:
        _, errors = db_map.update_wide_relationships(*sterilized_updates, strict=True)
        if errors:
            raise FlextoolException("Errors while updating relationships.")
    except SpineIntegrityError as e:
        raise FlextoolException(f"Database integrity error: {e}")


def _update_parameter_values(db_map, updates):
    """Updates parameter values in model database.

    Args:
        db_map (DatabaseMapping): database mapping
        updates (dict): database updates
    """
    value_updates = _get_and_validate(updates, "parameter_value", list, required=False)
    if not value_updates:
        return
    sterilized_updates = []
    for update in value_updates:
        sterilized = {}
        try:
            sterilized["id"] = update["id"]
            value = update["value"]
            value = _convert_ints_to_floats(value)
            sterilized["type"] = (
                None if not isinstance(value, dict) else value.pop("type")
            )
            sterilized["value"], _ = to_database(value)
        except KeyError as missing:
            raise FlextoolException(f"Missing'{missing}'.")
        sterilized_updates.append(sterilized)
    del value_updates  # Don't use updates from this point onwards.
    try:
        _, errors = db_map.update_parameter_values(*sterilized_updates, strict=True)
        if errors:
            raise FlextoolException("Errors while updating values.")
    except SpineIntegrityError as e:
        raise FlextoolException(f"Database integrity error: {e}")


def _insert_alternatives(db_map, insertions):
    """Inserts alternatives into model database.

    Args:
        db_map (DatabaseMapping): database mapping
        insertions (dict): database insertions

    Returns:
        dict: inserted alternative ids keyed by their names
    """
    alternative_insertions = _get_and_validate(
        insertions, "alternative", list, required=False
    )
    if not alternative_insertions:
        return {}
    sterilized_insertions = [
        {"name": _get_and_validate(insertion, "name", str)}
        for insertion in alternative_insertions
    ]
    try:
        inserted, errors = db_map.add_alternatives(
            *sterilized_insertions, strict=True, return_items=True
        )
        if errors:
            raise FlextoolException("Errors while inserting alternatives.")
    except SpineIntegrityError as e:
        raise FlextoolException(f"Database integrity error: {e}")
    return {i["name"]: i["id"] for i in inserted}


def _insert_scenarios(db_map, insertions):
    """Inserts scenarios into model database.

    Args:
        db_map (DatabaseMapping): database mapping
        insertions (dict): database insertions

    Returns:
        dict: inserted scenario ids keyed by their names
    """
    scenario_insertions = _get_and_validate(
        insertions, "scenario", list, required=False
    )
    if not scenario_insertions:
        return {}
    sterilized_insertions = [
        {"name": _get_and_validate(insertion, "name", str)}
        for insertion in scenario_insertions
    ]
    try:
        inserted, errors = db_map.add_scenarios(
            *sterilized_insertions, strict=True, return_items=True
        )
        if errors:
            raise FlextoolException("Errors while inserting scenarios.")
    except SpineIntegrityError as e:
        raise FlextoolException(f"Database integrity error: {e}")
    return {i["name"]: i["id"] for i in inserted}


def _insert_scenario_alternatives(db_map, insertions):
    """Inserts scenario alternatives into model database.

    Args:
        db_map (DatabaseMapping): database mapping
        insertions (dict): database insertions

    Returns:
        dict: inserted scenario alternative ids keyed by scenario names and ranks
    """
    scenario_alternative_insertions = _get_and_validate(
        insertions, "scenario_alternative", list, required=False
    )
    if not scenario_alternative_insertions:
        return {}
    scenario_ids = {row.name: row.id for row in db_map.query(db_map.scenario_sq)}
    scenario_names = {id_: name for name, id_ in scenario_ids.items()}
    alternative_ids = {row.name: row.id for row in db_map.query(db_map.alternative_sq)}
    sterilized_insertions = [
        {
            "scenario_id": scenario_ids[
                _get_and_validate(insertion, "scenario_name", str)
            ],
            "alternative_id": alternative_ids[
                _get_and_validate(insertion, "alternative_name", str)
            ],
            "rank": _get_and_validate(insertion, "rank", int),
        }
        for insertion in scenario_alternative_insertions
    ]
    try:
        inserted, errors = db_map.add_scenario_alternatives(
            *sterilized_insertions, strict=True, return_items=True
        )
        if errors:
            raise FlextoolException("Errors while inserting scenario alternatives.")
    except SpineIntegrityError as e:
        raise FlextoolException(f"Database integrity error: {e}")
    ids = {}
    for i in inserted:
        ids.setdefault(scenario_names[i["scenario_id"]], {})[i["rank"]] = i["id"]
    return ids


def _insert_objects(db_map, insertions, class_id):
    """Inserts objects into model database.

    Args:
        db_map (DatabaseMapping): database mapping
        insertions (dict): database insertions
        class_id (int): object class id

    Returns:
        dict: inserted object ids keyed by object names
    """
    object_insertions = _get_and_validate(insertions, "object", list, required=False)
    if not object_insertions:
        return {}
    if class_id is None:
        raise FlextoolException(f"'class_id' is required for object insertions")
    sterilized_insertions = []
    for insertion in object_insertions:
        name = _get_and_validate(insertion, "name", str)
        sterilized = {"name": name, "class_id": class_id}
        sterilized_insertions.append(sterilized)
    try:
        inserted, errors = db_map.add_objects(
            *sterilized_insertions, strict=True, return_items=True
        )
        if errors:
            raise FlextoolException("Errors while inserting objects.")
    except SpineIntegrityError as e:
        raise FlextoolException(f"Database integrity error: {e}")
    return {i["name"]: i["id"] for i in inserted}


def _insert_relationships(db_map, insertions, class_id):
    """Inserts objects into model database.

    Args:
        db_map (DatabaseMapping): database mapping
        insertions (dict): database insertions
        class_id (int): relationship class id

    Returns:
        dict: inserted object ids keyed by object names
    """
    relationship_insertions = _get_and_validate(
        insertions, "relationship", list, required=False
    )
    if not relationship_insertions:
        return {}
    if class_id is None:
        raise FlextoolException("'class_id' is required for relationship insertions")
    sterilized_insertions = []
    object_ids = _relationship_object_ids(db_map, class_id)
    for insertion in relationship_insertions:
        object_names = _get_and_validate(insertion, "object_name_list", list)
        object_id_list = [
            object_ids[dimension][object_names[dimension]]
            for dimension, ids in enumerate(object_ids)
        ]
        name = _get_and_validate(insertion, "name", str)
        sterilized = {
            "name": name,
            "class_id": class_id,
            "object_id_list": object_id_list,
        }
        sterilized_insertions.append(sterilized)
    try:
        inserted, errors = db_map.add_wide_relationships(
            *sterilized_insertions, strict=True, return_items=True
        )
        if errors:
            raise FlextoolException("Errors while inserting relationships.")
    except SpineIntegrityError as e:
        raise FlextoolException(f"Database integrity error: {e}")
    return {i["name"]: i["id"] for i in inserted}


def _insert_parameter_values(db_map, insertions, class_id):
    """Inserts parameter values into model database.

    Args:
        db_map (DatabaseMapping): database mapping
        insertions (dict): database insertions
        class_id (int): entity class id
    """
    value_insertions = _get_and_validate(
        insertions, "parameter_value", list, required=False
    )
    if not value_insertions:
        return
    if class_id is None:
        raise FlextoolException("'class_id' is required for parameter value insertions")
    sterilized_insertions = []
    definition_ids = set()
    for insertion in value_insertions:
        definition_id = _get_and_validate(insertion, "definition_id", int)
        definition_ids.add(definition_id)
        value = _get_and_validate(insertion, "value", (str, float, int, dict))
        value = _convert_ints_to_floats(value)
        value_type = None if not isinstance(value, dict) else value.pop("type")
        database_value, _ = to_database(value)
        sterilized = {
            "entity_class_id": class_id,
            "entity_name": _get_and_validate(insertion, "entity_name", str),
            "parameter_definition_id": definition_id,
            "alternative_id": _get_and_validate(insertion, "alternative_id", int),
            "value": database_value,
            "type": value_type,
        }
        sterilized_insertions.append(sterilized)
    entity_ids = {
        row.name: row.id
        for row in db_map.query(db_map.entity_sq).filter(
            db_map.entity_sq.c.class_id == class_id
        )
    }
    for insertion in sterilized_insertions:
        insertion["entity_id"] = entity_ids[insertion["entity_name"]]
    try:
        inserted, errors = db_map.add_parameter_values(
            *sterilized_insertions, strict=True, return_items=True
        )
        if errors:
            raise FlextoolException("Errors while inserting values.")
    except SpineIntegrityError as e:
        raise FlextoolException(f"Database integrity error: {e}")


def get_class_set(project, object_class_names):
    """Queries physical object and relationship classes in model database.

    Args:
        project (Project): target project
        object_class_names (set of str): set's object class names

    Returns:
        HttpResponse: physical entity classes
    """

    def relationship_class_rows_as_dicts(rows):
        relationships = [row._asdict() for row in rows]
        for relationship in relationships:
            relationship["entitiesUrl"] = reverse(
                "flextool3:entities",
                kwargs=dict(pk=project.id, class_id=relationship["id"]),
            )
        return relationships

    with database_map(project, Database.MODEL) as db_map:
        object_class_rows = iter(
            db_map.query(db_map.object_class_sq)
            .filter(db_map.object_class_sq.c.name.in_(object_class_names))
            .order_by(db_map.object_class_sq.c.name)
        )
        object_classes = []
        relationship_classes = {}
        for object_class_row in object_class_rows:
            object_class_dict = object_class_row._asdict()
            object_class_dict["entitiesUrl"] = reverse(
                "flextool3:entities",
                kwargs=dict(pk=project.id, class_id=object_class_row.id),
            )
            object_classes.append(object_class_dict)
            relationship_class_ids = {
                row.id
                for row in db_map.query(db_map.relationship_class_sq)
                .filter(db_map.relationship_class_sq.c.dimension == 0)
                .filter(
                    db_map.relationship_class_sq.c.object_class_id
                    == object_class_row.id
                )
            }
            relationship_class_rows = iter(
                db_map.query(db_map.wide_relationship_class_sq)
                .filter(
                    db_map.wide_relationship_class_sq.c.id.in_(relationship_class_ids)
                )
                .order_by(db_map.wide_relationship_class_sq.c.name)
            )
            relationship_classes[
                object_class_row.id
            ] = relationship_class_rows_as_dicts(relationship_class_rows)
        return JsonResponse(
            {
                "objectClasses": object_classes,
                "relationshipClasses": relationship_classes,
            }
        )


def get_alternatives(project, database):
    """Queries alternatives in one of project's databases.

    Args:
        project (Project): target project
        database (Database): target database

    Returns:
        HttpResponse: alternatives
    """
    with database_map(project, database) as db_map:
        return JsonResponse(
            {
                "alternatives": [
                    row._asdict()
                    for row in db_map.query(db_map.alternative_sq).order_by(
                        db_map.alternative_sq.c.name
                    )
                ]
            }
        )


def get_scenarios(project):
    """Queries scenarios and scenario alternatives in model database.

    Args:
        project (Project): target project

    Returns:
        HttpResponse: scenarios and scenario alternatives
    """
    with database_map(project, Database.MODEL) as db_map:
        scenario_alternatives = {}
        scenario_ids = {}
        for row in db_map.query(db_map.ext_scenario_sq).order_by(
            db_map.ext_scenario_sq.c.name, db_map.ext_scenario_sq.c.rank
        ):
            if row.alternative_name is not None:
                scenario_alternatives.setdefault(row.name, []).append(
                    row.alternative_name
                )
            else:
                scenario_alternatives[row.name] = []
            scenario_ids[row.name] = row.id
        scenario_data = []
        for scenario_name, alternatives in scenario_alternatives.items():
            scenario_data.append(
                {
                    "scenario_id": scenario_ids[scenario_name],
                    "scenario_name": scenario_name,
                    "scenario_alternatives": alternatives,
                }
            )
        return JsonResponse({"scenarios": scenario_data})


@contextmanager
def database_map(project, database):
    """Opens a database connection to project's database.

    Args:
        project (Project): project
        database (Database): database to connect to

    Yields:
        DatabaseMapping: database mapping connected to the database.
    """
    if database == Database.MODEL:
        url = "sqlite:///" + str(project.model_database_path())
    else:
        url = "sqlite:///" + str(project.results_database_path())
    db_map = DatabaseMapping(url)
    try:
        yield db_map
    finally:
        db_map.connection.close()


@login_required
def executions(request):
    """Responds to execution requests.

    Args:
        request (HTTPRequest): client's request

    Returns:
        HTTPResponse: response
    """
    if request.method != "POST":
        raise Http404()
    body = json.loads(request.body)
    try:
        question = _get_and_validate(body, "type", str)
    except FlextoolException as error:
        return HttpResponseBadRequest(str(error))
    if question == "execution list?":
        return execution_list(request, body)
    if question == "create execution?":
        return create_execution(request, body)
    if question == "destroy execution?":
        return destroy_execution(request, body)
    if question == "execute?":
        return execute(request, body)
    if question == "abort?":
        return abort_execution(request, body)
    if question == "briefing?":
        return execution_briefing(request, body)
    return HttpResponseBadRequest("Unknown 'type'.")


def execution_list(request, request_body):
    try:
        project = _resolve_project(request, request_body)
    except FlextoolException as error:
        return HttpResponseBadRequest(str(error))
    response = {
        "executions": [
            e.execution_list_data()
            for e in Execution.objects.filter(project_id=project.id)
        ]
    }
    return JsonResponse(response)


def create_execution(request, request_body):
    try:
        project = _resolve_project(request, request_body)
    except FlextoolException as error:
        return HttpResponseBadRequest(str(error))
    try:
        new_execution = Execution(project=project)
    except FlextoolException as error:
        return HttpResponseBadRequest(str(error))
    new_execution.save()
    return JsonResponse({"execution": new_execution.execution_list_data()})


def _resolve_execution(request, request_body):
    execution_id = _get_and_validate(request_body, "id", int)
    try:
        execution = Execution.objects.get(pk=execution_id)
    except Execution.DoesNotExist:
        raise FlextoolException("Execution does not exist.")
    if execution.project.user.id != request.user.id:
        raise FlextoolException("Execution does not exist.")
    return execution


def abort_execution(request, request_body):
    try:
        execution = _resolve_execution(request, request_body)
    except FlextoolException as error:
        return HttpResponseBadRequest(str(error))
    execution_id = execution.id
    executor.abort(execution_id)
    return JsonResponse({"id": execution_id})


def destroy_execution(request, request_body):
    try:
        execution = _resolve_execution(request, request_body)
    except FlextoolException as error:
        return HttpResponseBadRequest(str(error))
    execution_id = execution.id
    execution.delete()
    return JsonResponse({"id": execution_id})


def execute(request, request_body):
    try:
        execution = _resolve_execution(request, request_body)
    except FlextoolException as error:
        return HttpResponseBadRequest(str(error))
    execution.start(sys.executable, execution.arguments())
    return JsonResponse({"id": execution.id})


def execution_briefing(request, request_body):
    """Generates execution briefing response.

    Args:
        request (HTTPRequest): client's request
        request_body (dict): request body

    Returns:
        HTTPResponse: execution briefing
    """
    try:
        execution = _resolve_execution(request, request_body)
    except FlextoolException as error:
        return HttpResponseBadRequest(str(error))
    briefing = execution.briefing()
    return JsonResponse({"briefing": briefing})


@login_required
def summary(request):
    """Serves execution summaries.

    Args:
        request(HTTPRequest): client's request

    Returns:
        HTTPResponse: execution summary
    """
    if request.method != "POST":
        raise Http404()
    body = json.loads(request.body)
    try:
        project = _resolve_project(request, body)
    except FlextoolException as error:
        return HttpResponseBadRequest(str(error))
    try:
        type_ = body["type"]
    except KeyError as missing:
        return HttpResponseBadRequest(f"Missing '{missing}'.")
    if type_ == "summary?":
        return _get_summary(project)
    return HttpResponseBadRequest("Unknown 'type'.")


def number_to_float(x):
    """Converts x to float if possible.

    Args:
        x (Any): a value

    Returns:
        float or Any: float or x if conversion was unsuccessful
    """
    try:
        return float(x)
    except ValueError:
        return x


def _get_summary(project):
    """Generates a response that contains project's latest execution summary.

    Args:
        project (Project): a project

    Returns:
        HTTPResponse: a response object
    """
    summaries = project.summary_path()
    if not summaries:
        return JsonResponse({"summary": []})
    summary_path = next(iter(summaries.values()))
    with open(summary_path, encoding="utf-8") as summary_file:
        reader = csv.reader(summary_file)
        summary_rows = [[number_to_float(i) for i in row] for row in reader]
    return JsonResponse({"summary": summary_rows})


@login_required
def analysis(request):
    """Performs result database queries.

    Request's body should contain a JSON object that specifies the query to perform.

    Args:
        request (HttpRequest): request object

    Returns:
        HttpResponse: response to client
    """

    def handle_result_specific_types(type_, project, body):
        if type_ == "entity classes?":
            return get_entity_classes(project)
        return None

    return _resolve_interface_request(
        request, Database.RESULT, handle_result_specific_types
    )


def get_entity_classes(project):
    """Queries entity classes in of project's results database.

    Args:
        project (Project): target project

    Returns:
        HttpResponse: entity classes
    """
    with database_map(project, Database.RESULT) as db_map:
        classes = [row._asdict() for row in db_map.query(db_map.entity_class_sq)]
        return JsonResponse({"classes": classes})
