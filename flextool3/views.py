from enum import Enum, unique
import json
import re
from shutil import copyfile
from contextlib import contextmanager

from django.contrib.auth.decorators import login_required
from django.contrib.auth.mixins import LoginRequiredMixin
from django.http import (
    Http404,
    HttpResponse,
    HttpResponseBadRequest,
    JsonResponse,
    HttpResponseServerError,
)
from django.shortcuts import get_object_or_404, render
from django.urls import reverse
from django.views import generic
from spinedb_api import (
    DatabaseMapping,
    to_database,
    SpineIntegrityError,
    SpineDBVersionError,
    SpineDBAPIError,
)
from .models import Execution, Project, PROJECT_NAME_LENGTH
from . import executor, site
from .exception import FlextoolException

PHYSICAL_OBJECT_CLASS_NAMES = {
    "commodity",
    "connection",
    "group",
    "node",
    "profile",
    "reserve",
    "unit",
}


@unique
class Key(Enum):
    ALTERNATIVE_ID = "alternative_id"
    CLASS_ID = "class_id"
    ENTITY_ID = "entity_id"
    OBJECT_CLASS_ID = "object_class_id"
    OBJECT_ID = "object_id"
    RELATIONSHIP_CLASS_ID = "relationship_class_id"
    VALUE_LIST_IDS = "value_list_ids"

    def __str__(self):
        return self.value


def _get_and_validate(dictionary, key, expected_type):
    """Returns value with given key from dictionary.

    Raises if value doesn't exist or is of wrong type.

    Args:
        dictionary (dict): a dictionary
        key (Any): dictionary key
        expected_type (Type): value's expected type
    """
    try:
        x = dictionary[key]
    except KeyError as missing:
        raise FlextoolException(f"Missing {missing}.")
    if not isinstance(x, expected_type):
        if isinstance(expected_type, tuple):
            raise FlextoolException(
                f"'{key}' is of wrong type, expected one of {expected_type}"
            )
        else:
            raise FlextoolException(
                f"'{key}' is of wrong type '{type(x).__name__}', expected {expected_type.__name__}"
            )
    return x


def _convert_ints_to_floats(value):
    """Converts integers to floats in-place in indexed values.

    Args:
        value (Any): parameter value

    Returns:
        Any: value converted to float
    """
    if isinstance(value, int):
        return float(value)
    if not isinstance(value, dict):
        return value
    type_ = value["type"]
    if type_ == "map":
        data = [[x, float(y) if isinstance(y, int) else y] for x, y in value["data"]]
        value["data"] = data
    elif type == "array":
        data = [float(y) if isinstance(y, int) else y for y in value["data"]]
        value["data"] = data
    return value


class IndexView(LoginRequiredMixin, generic.ListView):
    template_name = "flextool3/index.html"
    context_object_name = "projects"
    login_url = "accounts/login/"

    def get_queryset(self):
        """Returns user's projects."""
        return Project.objects.filter(user_id=self.request.user.id)


class DetailView(LoginRequiredMixin, generic.DetailView):
    model = Project
    template_name = "flextool3/detail.html"


def _ensure_model_database_up_to_date(func, request, pk):
    """Returns special response if model database needs an upgrade; otherwise returns response generated by func.

    Args:
        func (Callable): function returning HttpResponse
        request (HttpRequest): request object
        pk (int): project's primary key

    Returns:
        HttpResponse: response object
    """
    project = get_object_or_404(Project, pk=pk)
    db_url = "sqlite:///" + str(project.model_database_path())
    try:
        db_map = DatabaseMapping(db_url)
    except SpineDBVersionError:
        _backup_database(project.model_database_path())
        try:
            db_map = DatabaseMapping(db_url, upgrade=True)
        except SpineDBAPIError as error:
            return HttpResponseServerError(f"Failed to upgrade database: {error}")
        else:
            db_map.connection.close()
            return render(request, "flextool3/database_upgraded.html")
    except SpineDBAPIError as error:
        return HttpResponseServerError(f"Failed to open database mapping: {error}")
    else:
        try:
            return func(project, db_map)
        finally:
            db_map.connection.close()


def _backup_database(database_path):
    """Backs up a file.

    Args:
        database_path (Path): path to .sqlite file
    """
    backup_path = database_path.parent / (database_path.name + ".backup")
    copyfile(database_path, backup_path)


@login_required
def edit(request, pk):
    def render_edit(project, _):
        context = {"project": project}
        return render(request, "flextool3/edit.html", context)

    return _ensure_model_database_up_to_date(render_edit, request, pk)


@login_required
def entities(request, pk, class_id):
    def render_entities(project, db_map):
        entity_class = (
            db_map.query(db_map.entity_class_sq)
            .filter(db_map.entity_class_sq.c.id == class_id)
            .first()
        )
        if entity_class is None:
            return HttpResponseBadRequest("Entity class does not exist.")
        context = {"project": project, "entity_class": entity_class}
        return render(request, "flextool3/entities.html", context)

    return _ensure_model_database_up_to_date(render_entities, request, pk)


class SolveView(LoginRequiredMixin, generic.DetailView):
    model = Project
    template_name = "flextool3/solve.html"


class ResultsView(LoginRequiredMixin, generic.DetailView):
    model = Project
    template_name = "flextool3/results.html"


@login_required
def projects(request):
    if request.method != "POST":
        raise Http404()
    body = json.loads(request.body)
    try:
        question = body["type"]
    except KeyError as missing:
        return HttpResponseBadRequest(f"Missing '{missing}'.")
    if question == "project list?":
        return project_list(request.user.id)
    if question == "create project?":
        return create_project(request.user, body)
    if question == "destroy project?":
        return destroy_project(request.user, body)
    return HttpResponseBadRequest("Unknown 'type'.")


def project_list(user_id):
    response = {
        "projects": [
            project.project_list_data()
            for project in Project.objects.filter(user_id=user_id)
        ]
    }
    return JsonResponse(response)


def create_project(user, request_body):
    try:
        project_name = request_body["name"]
    except KeyError as missing:
        return HttpResponseBadRequest(f"Missing '{missing}'")
    project_name = project_name[:PROJECT_NAME_LENGTH].strip()
    if re.match(r"(^\w&)|(^\w(\w|\s)*\w$)", project_name) is None:
        return HttpResponseBadRequest("Invalid project name.")
    try:
        new_project = Project.create(
            user,
            project_name,
            site.FLEXTOOL_PROJECTS_ROOT,
            site.FLEXTOOL_PROJECT_TEMPLATE,
        )
    except FlextoolException as error:
        return HttpResponseBadRequest(str(error))
    new_project.save()
    return JsonResponse({"project": new_project.project_list_data()})


def destroy_project(user, request_body):
    """Destroys a project by it from the database and removing the project directory.

    Args:
        user (User): project owner
        request_body (dict): destroy request body

    Returns:
        HttpResponse: response to be sent to client
    """
    try:
        id_ = request_body["id"]
    except KeyError as missing:
        return HttpResponseBadRequest(f"Missing '{missing}'.")
    try:
        project = Project.objects.get(user_id=user.id, pk=id_)
    except Project.DoesNotExist:
        return HttpResponseBadRequest("Project does not exist.")
    project.remove_project_dir()
    project.delete()
    return JsonResponse({"id": id_})


@login_required
def model(request):
    """Performs model database queries and updates.

    Request's body should contain a JSON object that specifies the query/update to perform.

    Args:
        request (HttpRequest): request object

    Returns:
        HttpResponse: response to client
    """
    if request.method != "POST":
        raise Http404()
    body = json.loads(request.body)
    try:
        project = _resolve_project(request, body)
    except FlextoolException as error:
        return HttpResponseBadRequest(str(error))
    try:
        type_ = body["type"]
    except KeyError as missing:
        return HttpResponseBadRequest(f"Missing '{missing}'.")
    try:
        if type_ == "object classes?":
            return get_object_classes(project)
        if type_ == "objects?":
            return get_objects(project, body)
        if type_ == "relationship classes?":
            return get_relationship_classes(project)
        if type_ == "relationships?":
            return get_relationships(project, body)
        if type_ == "available relationship objects?":
            return get_available_relationship_objects(project, body)
        if type_ == "parameter definitions?":
            return get_parameter_definitions(project, body)
        if type_ == "parameter values?":
            return get_parameter_values(project, body)
        if type_ == "parameter value lists?":
            return get_parameter_value_lists(project, body)
        if type_ == "physical classes?":
            return get_physical_classes(project)
        if type_ == "alternatives?":
            return get_alternatives(project)
        if type_ == "commits?":
            return get_commits(project, body)
        if type_ == "commit":
            return commit(project, body)
    except SpineDBVersionError:
        return HttpResponseBadRequest("Error: database version mismatch.")
    return HttpResponseBadRequest("Unknown 'type'.")


def _resolve_project(request, body):
    """Resolves target project according to client request.

    Args:
        request (HttpRequest): request object
        body (dict): request body

    Returns:
        Project: target project
    """
    try:
        project_id = body["projectId"]
    except KeyError as missing:
        raise FlextoolException(f"Missing '{missing}'.")
    try:
        project = Project.objects.get(id=project_id)
    except Project.DoesNotExist:
        raise FlextoolException("Project does not exist.")
    if project.user.id != request.user.id:
        raise FlextoolException("Project does not exist.")
    return project


def get_object_classes(project):
    """Queries object classes in model database.

    Args:
        project (Project): target project

    Returns:
        HttpResponse: object classes
    """
    with model_database_map(project) as db_map:
        classes = [row._asdict() for row in db_map.query(db_map.object_class_sq)]
        return JsonResponse({"classes": classes})


def get_objects(project, request_body):
    """Queries objects in model database.

    Optional entries in request body:

    - 'object_class_id': object class id for filtering

    Args:
        project (Project): target project
        request_body (dict): request body

    Returns:
        HttpResponse: objects
    """
    class_id = request_body.get(Key.OBJECT_CLASS_ID.value)
    if class_id is not None and not isinstance(class_id, int):
        return HttpResponseBadRequest(f"Wrong '{Key.OBJECT_CLASS_ID}' data type.")
    with model_database_map(project) as db_map:
        sq = db_map.object_sq
        if class_id is not None:
            sq = db_map.query(sq).filter(sq.c.class_id == class_id).subquery()
        objects = [row._asdict() for row in db_map.query(sq).order_by(sq.c.name)]
        return JsonResponse({"objects": objects})


def get_parameter_definitions(project, request_body):
    """Queries entity parameter definitions in model database.

    Optional entries in request body:

    - 'class_id': entity class id for filtering

    Args:
        project (Project): target project
        request_body (dict): request body

    Returns:
        HttpResponse: entity parameter definitions
    """
    class_id = request_body.get(Key.CLASS_ID.value)
    if class_id is not None and not isinstance(class_id, int):
        return HttpResponseBadRequest(f"Wrong '{Key.CLASS_ID}' data type.")
    with model_database_map(project) as db_map:
        sq = db_map.parameter_definition_sq
        if class_id is not None:
            sq = db_map.query(sq).filter(sq.c.entity_class_id == class_id).subquery()
        definitions = [row._asdict() for row in db_map.query(sq).order_by(sq.c.name)]
        for definition in definitions:
            value_bytes = definition["default_value"]
            if value_bytes is not None:
                definition["default_value"] = str(value_bytes, encoding="utf-8")
        return JsonResponse({"definitions": definitions})


def get_parameter_values(project, request_body):
    """Queries entity parameter values in model database.

    Optional entries in request body:

    - 'class_id': entity class id for filtering
    - 'entity_id': entity id for filtering, ignored if entity_class_id is given
    - 'alternative_id' alternative id for filtering

    Args:
        project (Project): target project
        request_body (dict): request body

    Returns:
        HttpResponse: parameter values
    """
    class_id = request_body.get(Key.CLASS_ID.value)
    if class_id is not None and not isinstance(class_id, int):
        return HttpResponseBadRequest(f"Wrong '{Key.CLASS_ID}' data type.")
    entity_id = request_body.get(Key.ENTITY_ID.value)
    if entity_id is not None and not isinstance(entity_id, int):
        return HttpResponseBadRequest(f"Wrong '{Key.ENTITY_ID}' data type.")
    alternative_id = request_body.get(Key.ALTERNATIVE_ID.value)
    if alternative_id is not None and not isinstance(alternative_id, int):
        return HttpResponseBadRequest(f"Wrong '{Key.ALTERNATIVE_ID}' data type.")
    with model_database_map(project) as db_map:
        sq = db_map.parameter_value_sq
        if class_id is not None:
            sq = db_map.query(sq).filter(sq.c.entity_class_id == class_id).subquery()
        elif entity_id is not None:
            sq = db_map.query(sq).filter(sq.c.entity_id == entity_id).subquery()
        if alternative_id is not None:
            sq = (
                db_map.query(sq)
                .filter(sq.c.alternative_id == alternative_id)
                .subquery()
            )
        values = [row._asdict() for row in db_map.query(sq)]
        for value in values:
            value_bytes = value["value"]
            if value_bytes is not None:
                value["value"] = str(value_bytes, encoding="utf-8")
        return JsonResponse({"values": values})


def get_relationship_classes(project):
    """Queries relationship classes in model database.

    Args:
        project (Project): target project

    Returns:
        HttpResponse: relationship classes
    """
    with model_database_map(project) as db_map:
        classes = [
            row._asdict() for row in db_map.query(db_map.ext_relationship_class_sq)
        ]
        return JsonResponse({"classes": classes})


def _relationship_object_ids(db_map, class_id):
    """Gather's names and ids of all objects that belong to relationship class' dimensions.

    Args:
        db_map (DatabaseMapping): database map
        class_id (int): relationship class id

    Returns:
        list of dict: dicts of object ids keyed by names; the dicts are sorted by relationship dimension
    """
    class_components = (
        db_map.query(db_map.ext_relationship_class_sq)
        .filter(db_map.ext_relationship_class_sq.c.id == class_id)
        .order_by(db_map.ext_relationship_class_sq.c.dimension)
        .all()
    )
    object_ids = list()
    for component in class_components:
        objects = (
            db_map.query(db_map.object_sq)
            .filter(db_map.object_sq.c.class_id == component.object_class_id)
            .all()
        )
        object_ids.append({o.name: o.id for o in objects})
    return object_ids


def get_relationships(project, request_body):
    """Queries relationships in model database.

    Optional entries in request body:

    - 'relationship_class_id': relationship class id for filtering

    Args:
        project (Project): target project
        request_body (dict): request body

    Returns:
        HttpResponse: relationships
    """
    class_id = request_body.get(Key.RELATIONSHIP_CLASS_ID.value)
    if class_id is not None and not isinstance(class_id, int):
        return HttpResponseBadRequest(f"Wrong '{Key.RELATIONSHIP_CLASS_ID}' data type.")
    with model_database_map(project) as db_map:
        sq = db_map.ext_relationship_sq
        if class_id is not None:
            sq = db_map.query(sq).filter(sq.c.class_id == class_id).subquery()
        relationships = [
            row._asdict()
            for row in db_map.query(sq).order_by(sq.c.name, sq.c.dimension)
        ]
        return JsonResponse({"relationships": relationships})


def get_available_relationship_objects(project, request_body):
    """Queries objects of relationship's object classes in model database.

    Required entries in request body:

    - 'relationship_class_id': relationship class id

    Args:
        project (Project): target project
        request_body (dict): request body

    Returns:
        HttpResponse: lists of names of available objects for each relationship dimension
    """
    class_id = _get_and_validate(request_body, Key.RELATIONSHIP_CLASS_ID.value, int)
    with model_database_map(project) as db_map:
        available_objects = []
        for names_and_ids in _relationship_object_ids(db_map, class_id):
            available_objects.append(sorted(names_and_ids))
        return JsonResponse({"available_objects": available_objects})


def get_parameter_value_lists(project, request_body):
    """Queries parameter value lists in model database.

    Optional entries in request body:

    - 'value_list_ids': list of parameter list ids for filtering

    Args:
        project (Project): target project
        request_body (dict): request body

    Returns:
        HttpResponse: parameter value lists
    """

    def concatenate_bag(bag):
        skeleton = len(bag) * [None]
        for index, x in bag.items():
            skeleton[index] = x
        return skeleton

    list_ids = request_body.get(Key.VALUE_LIST_IDS.value)
    if list_ids is not None:
        if not isinstance(list_ids, list):
            return HttpResponseBadRequest(f"Wrong '{Key.VALUE_LIST_IDS}' data type.")
        if any(not isinstance(id_, int) for id_ in list_ids):
            return HttpResponseBadRequest(f"Wrong data type in '{Key.VALUE_LIST_IDS}'.")
    with model_database_map(project) as db_map:
        sq = db_map.ord_list_value_sq
        if list_ids is not None:
            sq = (
                db_map.query(sq)
                .filter(sq.c.parameter_value_list_id.in_(list_ids))
                .subquery()
            )
        value_list_items = db_map.query(sq).all()
        collected_values = dict()
        collected_types = dict()
        for list_item in value_list_items:
            bag_of_values = collected_values.setdefault(
                list_item.parameter_value_list_id, dict()
            )
            bag_of_values[list_item.index] = str(list_item.value, encoding="utf-8")
            bag_of_types = collected_types.setdefault(
                list_item.parameter_value_list_id, dict()
            )
            bag_of_types[list_item.index] = list_item.type
        concatenated_values = {
            list_id: concatenate_bag(bag) for list_id, bag in collected_values.items()
        }
        concatenated_types = {
            list_id: concatenate_bag(bag) for list_id, bag in collected_types.items()
        }
        value_lists = []
        for list_item in value_list_items:
            values = concatenated_values.pop(list_item.parameter_value_list_id, None)
            if values is None:
                continue
            dictified = {
                "id": list_item.parameter_value_list_id,
                "value_list": values,
                "type_list": concatenated_types.pop(list_item.parameter_value_list_id),
            }
            value_lists.append(dictified)
        return JsonResponse({"lists": value_lists})


def get_commits(project, request_body):
    """Queries commits in model database.

    Args:
        project (Project): target project
        request_body (dict): request body

    Returns:
        HttpResponse: commits
    """
    with model_database_map(project) as db_map:
        commits = [row._asdict() for row in db_map.query(db_map.commit_sq)]
        # The last commit is always a dummy one.
        return JsonResponse({"commits": commits})


def commit(project, request_body):
    """Updates model database.

    Args:
        project (Project): target project
        request_body (dict): request body

    Returns:
        HttpResponse: commit status or error message
    """
    try:
        commit_message = request_body["message"]
    except KeyError as missing:
        return HttpResponseBadRequest(f"Missing '{missing}'.")
    if not isinstance(commit_message, str):
        return HttpResponseBadRequest("Commit message is of wrong type.")
    with model_database_map(project) as db_map:
        try:
            _delete_from_model(db_map, request_body)
            inserted = _insert_to_model(db_map, request_body)
            _update_model(db_map, request_body)
        except SpineIntegrityError as e:
            return HttpResponseBadRequest(f"Database integrity error: {e}")
        except FlextoolException as e:
            return HttpResponseBadRequest(str(e))
        try:
            db_map.commit_session(commit_message)
        except SpineDBAPIError as e:
            return HttpResponseBadRequest(f"Failed to commit: {e}")
        return JsonResponse({"inserted": inserted} if inserted else {})


def _update_model(db_map, request_body):
    """Updates model database.

    Args:
        db_map (DatabaseMapping): database mapping
        request_body (dict): request body
    """
    updates = request_body.get("updates")
    if updates is None:
        return
    if not isinstance(updates, dict):
        raise FlextoolException(f"'updates' wasn't of expected type.")
    class_id = request_body.get(Key.CLASS_ID.value)
    _update_objects(db_map, updates)
    _update_relationships(db_map, updates, class_id)
    _update_parameter_values(db_map, updates)


def _delete_from_model(db_map, request_body):
    """Deletes items from model database.

    Args:
        db_map (DatabaseMapping): database mapping
        request_body (dict): request body
    """
    deletions = request_body.get("deletions")
    if deletions is None:
        return
    if not isinstance(deletions, dict):
        raise FlextoolException(f"'deletions' wasn't of expected type.")
    try:
        converted_deletions = {key: set(value) for key, value in deletions.items()}
    except TypeError:
        raise FlextoolException("Wrong data type in deletions.")
    db_map.cascade_remove_items(cache=None, **converted_deletions)


def _insert_to_model(db_map, request_body):
    """Inserts items to model database.

    Args:
        db_map (DatabaseMapping): database mapping
        request_body (dict): request body

    Returns:
        dict of dict: inserted item ids
    """
    insertions = request_body.get("insertions")
    if insertions is None:
        return
    if not isinstance(insertions, dict):
        raise FlextoolException(f"'insertions' wasn't of expected type.")
    class_id = _get_and_validate(request_body, Key.CLASS_ID.value, int)
    inserted = {}
    objects = _insert_objects(db_map, insertions, class_id)
    if objects:
        inserted["object"] = objects
    relationships = _insert_relationships(db_map, insertions, class_id)
    if relationships:
        inserted["relationship"] = relationships
    _insert_parameter_values(db_map, insertions, class_id)
    return inserted


def _update_objects(db_map, updates):
    """Updates objects in model database.

    Args:
        db_map (DatabaseMapping): database mapping
        updates (dict): database updates
    """
    object_updates = updates.get("object")
    if not object_updates:
        return
    if not isinstance(object_updates, list):
        raise FlextoolException(f"'object' wasn't of expected type.")
    sterilized_updates = []
    for update in object_updates:
        sterilized = {
            "id": _get_and_validate(update, "id", int),
            "name": _get_and_validate(update, "name", str),
        }
        sterilized_updates.append(sterilized)
    del object_updates  # Don't use updates from this point onwards.
    try:
        _, errors = db_map.update_objects(*sterilized_updates, strict=True)
        if errors:
            raise FlextoolException("Errors while updating objects.")
    except SpineIntegrityError as e:
        raise FlextoolException(f"Database integrity error: {e}")


def _update_relationships(db_map, updates, class_id):
    """Updates relationships in model database.

    Args:
        db_map (DatabaseMapping): database mapping
        updates (dict): database updates
        class_id (int): relationship class id
    """
    relationship_updates = updates.get("relationship")
    if not relationship_updates:
        return
    if not isinstance(relationship_updates, list):
        raise FlextoolException(f"'relationship' wasn't of expected type.")
    if not isinstance(class_id, int):
        raise FlextoolException(f"'class_id' wasn't of expected type.")
    sterilized_updates = []
    object_ids = _relationship_object_ids(db_map, class_id)
    for update in relationship_updates:
        object_names = _get_and_validate(update, "object_name_list", list)
        object_id_list = [
            object_ids[dimension][object_names[dimension]]
            for dimension, ids in enumerate(object_ids)
        ]
        sterilized = {
            "id": _get_and_validate(update, "id", int),
            "name": _get_and_validate(update, "name", str),
            "object_id_list": object_id_list,
        }
        sterilized_updates.append(sterilized)
    del relationship_updates  # Don't use updates from this point onwards.
    try:
        _, errors = db_map.update_wide_relationships(*sterilized_updates, strict=True)
        if errors:
            raise FlextoolException("Errors while updating relationships.")
    except SpineIntegrityError as e:
        raise FlextoolException(f"Database integrity error: {e}")


def _update_parameter_values(db_map, updates):
    """Updates parameter values in model database.

    Args:
        db_map (DatabaseMapping): database mapping
        updates (dict): database updates
    """
    value_updates = updates.get("parameter_value")
    if not value_updates:
        return
    if not isinstance(value_updates, list):
        raise FlextoolException(f"'parameter_value' wasn't of expected type.")
    sterilized_updates = []
    for update in value_updates:
        sterilized = {}
        try:
            sterilized["id"] = update["id"]
            value = update["value"]
            value = _convert_ints_to_floats(value)
            sterilized["value"], sterilized["type"] = to_database(value)
        except KeyError as missing:
            raise FlextoolException(f"Missing'{missing}'.")
        sterilized_updates.append(sterilized)
    del value_updates  # Don't use updates from this point onwards.
    try:
        _, errors = db_map.update_parameter_values(*sterilized_updates, strict=True)
        if errors:
            raise FlextoolException("Errors while updating values.")
    except SpineIntegrityError as e:
        raise FlextoolException(f"Database integrity error: {e}")


def _insert_objects(db_map, insertions, class_id):
    """Inserts objects into model database.

    Args:
        db_map (DatabaseMapping): database mapping
        insertions (dict): database insertions
        class_id (int): object class id

    Returns:
        dict: inserted object ids keyed by object names
    """
    object_insertions = insertions.get("object")
    if not object_insertions:
        return {}
    if not isinstance(object_insertions, list):
        raise FlextoolException(f"'object' wasn't of expected type.")
    sterilized_insertions = []
    for insertion in object_insertions:
        name = _get_and_validate(insertion, "name", str)
        sterilized = {"name": name, "class_id": class_id}
        sterilized_insertions.append(sterilized)
    try:
        inserted, errors = db_map.add_objects(
            *sterilized_insertions, strict=True, return_items=True
        )
        if errors:
            raise FlextoolException("Errors while inserting objects.")
    except SpineIntegrityError as e:
        raise FlextoolException(f"Database integrity error: {e}")
    return {i["name"]: i["id"] for i in inserted}


def _insert_relationships(db_map, insertions, class_id):
    """Inserts objects into model database.

    Args:
        db_map (DatabaseMapping): database mapping
        insertions (dict): database insertions
        class_id (int): relationship class id

    Returns:
        dict: inserted object ids keyed by object names
    """
    relationship_insertions = insertions.get("relationship")
    if not relationship_insertions:
        return {}
    if not isinstance(relationship_insertions, list):
        raise FlextoolException(f"'relationship' wasn't of expected type.")
    sterilized_insertions = []
    object_ids = _relationship_object_ids(db_map, class_id)
    for insertion in relationship_insertions:
        object_names = _get_and_validate(insertion, "object_name_list", list)
        object_id_list = [
            object_ids[dimension][object_names[dimension]]
            for dimension, ids in enumerate(object_ids)
        ]
        name = _get_and_validate(insertion, "name", str)
        sterilized = {
            "name": name,
            "class_id": class_id,
            "object_id_list": object_id_list,
        }
        sterilized_insertions.append(sterilized)
    try:
        inserted, errors = db_map.add_wide_relationships(
            *sterilized_insertions, strict=True, return_items=True
        )
        if errors:
            raise FlextoolException("Errors while inserting relationships.")
    except SpineIntegrityError as e:
        raise FlextoolException(f"Database integrity error: {e}")
    return {i["name"]: i["id"] for i in inserted}


def _insert_parameter_values(db_map, insertions, class_id):
    """Inserts parameter values into model database.

    Args:
        db_map (DatabaseMapping): database mapping
        insertions (dict): database insertions
        class_id (int): entity class id
    """
    value_insertions = insertions.get("parameter_value")
    if not value_insertions:
        return {}
    if not isinstance(value_insertions, list):
        raise FlextoolException(f"'parameter_value' wasn't of expected type.")
    sterilized_insertions = []
    definition_ids = set()
    for insertion in value_insertions:
        definition_id = _get_and_validate(insertion, "definition_id", int)
        definition_ids.add(definition_id)
        value = _get_and_validate(insertion, "value", (str, float, int, dict))
        value = _convert_ints_to_floats(value)
        database_value, value_type = to_database(value)
        sterilized = {
            "entity_class_id": class_id,
            "entity_name": _get_and_validate(insertion, "entity_name", str),
            "parameter_definition_id": definition_id,
            "alternative_id": _get_and_validate(insertion, "alternative_id", int),
            "value": database_value,
            "type": value_type,
        }
        sterilized_insertions.append(sterilized)
    entity_ids = {
        row.name: row.id
        for row in db_map.query(db_map.entity_sq).filter(
            db_map.entity_sq.c.class_id == class_id
        )
    }
    for insertion in sterilized_insertions:
        insertion["entity_id"] = entity_ids[insertion["entity_name"]]
    try:
        inserted, errors = db_map.add_parameter_values(
            *sterilized_insertions, strict=True, return_items=True
        )
        if errors:
            raise FlextoolException("Errors while inserting values.")
    except SpineIntegrityError as e:
        raise FlextoolException(f"Database integrity error: {e}")


def get_physical_classes(project):
    """Queries physical object and relationship classes in model database.

    Args:
        project (Project): target project

    Returns:
        HttpResponse: physical entity classes
    """

    def relationship_class_rows_as_dicts(rows):
        relationships = [row._asdict() for row in rows]
        for relationship in relationships:
            relationship["entitiesUrl"] = reverse(
                "flextool3:entities",
                kwargs=dict(pk=project.id, class_id=relationship["id"]),
            )
        return relationships

    with model_database_map(project) as db_map:
        object_class_rows = iter(
            db_map.query(db_map.object_class_sq)
            .filter(db_map.object_class_sq.c.name.in_(PHYSICAL_OBJECT_CLASS_NAMES))
            .order_by(db_map.object_class_sq.c.name)
        )
        object_classes = []
        relationship_classes = {}
        for object_class_row in object_class_rows:
            object_class_dict = object_class_row._asdict()
            object_class_dict["entitiesUrl"] = reverse(
                "flextool3:entities",
                kwargs=dict(pk=project.id, class_id=object_class_row.id),
            )
            object_classes.append(object_class_dict)
            relationship_class_ids = {
                row.id
                for row in db_map.query(db_map.relationship_class_sq)
                .filter(db_map.relationship_class_sq.c.dimension == 0)
                .filter(
                    db_map.relationship_class_sq.c.object_class_id
                    == object_class_row.id
                )
            }
            relationship_class_rows = iter(
                db_map.query(db_map.wide_relationship_class_sq)
                .filter(
                    db_map.wide_relationship_class_sq.c.id.in_(relationship_class_ids)
                )
                .order_by(db_map.wide_relationship_class_sq.c.name)
            )
            relationship_classes[
                object_class_row.id
            ] = relationship_class_rows_as_dicts(relationship_class_rows)
        return JsonResponse(
            {
                "objectClasses": object_classes,
                "relationshipClasses": relationship_classes,
            }
        )


def get_alternatives(project):
    """Queries alternatives in model database.

    Args:
        project (Project): target project

    Returns:
        HttpResponse: alternatives
    """
    with model_database_map(project) as db_map:
        return JsonResponse(
            {
                "alternatives": [
                    row._asdict()
                    for row in db_map.query(db_map.alternative_sq).order_by(
                        db_map.alternative_sq.c.name
                    )
                ]
            }
        )


@contextmanager
def model_database_map(project):
    """Opens a database connection to project's model database."""
    db_map = DatabaseMapping("sqlite:///" + str(project.model_database_path()))
    try:
        yield db_map
    finally:
        db_map.connection.close()


@login_required
def executions(request):
    if request.method != "POST":
        raise Http404()
    body = json.loads(request.body)
    try:
        question = body["type"]
    except KeyError as missing:
        return HttpResponseBadRequest(f"Missing '{missing}'.")
    if question == "execution list?":
        return execution_list(request, body)
    if question == "create execution?":
        return create_execution(request, body)
    if question == "destroy execution?":
        return destroy_execution(request, body)
    if question == "execute?":
        return execute(request, body)
    if question == "abort?":
        return abort_execution(request, body)
    if question == "updates?":
        return execution_updates(request, body)
    if question == "log?":
        return execution_log(request, body)
    if question == "status?":
        return execution_status(request, body)
    return HttpResponseBadRequest("Unknown 'type'.")


def execution_list(request, request_body):
    try:
        project = _resolve_project(request, request_body)
    except FlextoolException as error:
        return HttpResponseBadRequest(str(error))
    response = {
        "executions": [
            e.execution_list_data()
            for e in Execution.objects.filter(project_id=project.id)
        ]
    }
    return JsonResponse(response)


def create_execution(request, request_body):
    try:
        project = _resolve_project(request, request_body)
    except FlextoolException as error:
        return HttpResponseBadRequest(str(error))
    try:
        new_execution = Execution(project=project)
    except FlextoolException as error:
        return HttpResponseBadRequest(str(error))
    new_execution.save()
    return JsonResponse({"execution": new_execution.execution_list_data()})


def _resolve_execution(request, request_body):
    try:
        execution_id = request_body["id"]
    except KeyError as missing:
        raise FlextoolException(f"missing '{missing}")
    try:
        execution = Execution.objects.get(pk=execution_id)
    except Execution.DoesNotExist:
        raise FlextoolException("Execution does not exist.")
    if execution.project.user.id != request.user.id:
        raise FlextoolException("Execution does not exist.")
    return execution


def abort_execution(request, request_body):
    try:
        execution = _resolve_execution(request, request_body)
    except FlextoolException as error:
        return HttpResponseBadRequest(str(error))
    execution_id = execution.id
    executor.abort(execution_id)
    return JsonResponse({"id": execution_id})


def destroy_execution(request, request_body):
    try:
        execution = _resolve_execution(request, request_body)
    except FlextoolException as error:
        return HttpResponseBadRequest(str(error))
    execution_id = execution.id
    execution.delete()
    return JsonResponse({"id": execution_id})


def execute(request, request_body):
    try:
        execution = _resolve_execution(request, request_body)
    except FlextoolException as error:
        return HttpResponseBadRequest(str(error))
    execution.start(site.SPINE_TOOLBOX_PYTHON, execution.arguments())
    return JsonResponse({"id": execution.id})


def execution_updates(request, request_body):
    try:
        execution = _resolve_execution(request, request_body)
    except FlextoolException as error:
        return HttpResponseBadRequest(str(error))
    updates = execution.updates()
    return JsonResponse({"updates": updates})


def execution_log(request, request_body):
    try:
        execution = _resolve_execution(request, request_body)
    except FlextoolException as error:
        return HttpResponseBadRequest(str(error))
    log = execution.log.split("\n")
    return JsonResponse({"log": log})


def execution_status(request, request_body):
    try:
        execution = _resolve_execution(request, request_body)
    except FlextoolException as error:
        return HttpResponseBadRequest(str(error))
    return JsonResponse({"status": execution.status})
